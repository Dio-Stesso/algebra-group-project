@page "/polinomial-ring"
@using System.ComponentModel.DataAnnotations;
@using System.Text;
@using AlgebraWASM.Client;
@using System.Runtime.InteropServices;

<div style="margin-left: 30%;">
	<select @onchange="SelectedMethod">
		<option value="">--Оберіть метод--</option>
		<option value="11">11. Додавання, віднімання, множення двох многочленів.</option>
		<option value="12">12. Знаходження похідної многочлена.</option>
		<option value="13">13. Знаходження частки та остачі від ділення.</option>
		<option value="14">14. Знаходження кругового многочлена.</option>
	</select>
	<div style="display: flex; margin-left: 20px; gap: 10px; margin-top: 15px">
		<label for="@coefModule">Coefficient module: </label>
		<input name="coef-module" type="input" @bind-value="@coefModule" />
	</div>
	@switch (selected)
	{
		case "11":
			<div>
				<p>Enter two numbers:</p>
				<input type="text" @bind-value="@firstInputBox" />
				<input type="text" @bind-value="@secondInputBox" />
				<button @onclick="Add"> Add </button>
				<button @onclick="Subtract"> Subtract </button>
				<button @onclick="Multiply"> Multiply </button>
					<p>@result</p>
			</div>
			break;
@*		case "12":
			<div>
				<p>Enter two numbers:</p>
				<input type="text" @bind-value="@firstInputBox" />
				<button @onclick="Derivative"> Derivative </button>
				<button @onclick="Evaluate"> Evaluate </button>
					<p>@result</p>
			</div>
			break;
		case "13":
			<div>
				<p>Enter two numbers:</p>
				<input type="text" @bind-value="@firstInputBox" />
				<input type="text" @bind-value="@secondInputBox" />
				<button @onclick="Division"> Division </button>
				<button @onclick="GCD"> GCD </button>
					<p>@result</p>
			</div>
			break;
		case "14":
			<div>
				<p>Enter two numbers:</p>
				<input type="text" @bind-value="@firstInputBox" />
				<button @onclick="Calculate"> Calculate </button>
					<p>@result</p>
			</div>
			break;*@
		default:
			break;
	}
</div>




@code {
	public string selected { get; set; } = "";
	public string result { get; set; } = "";
	public string errStr { get; set; } = "";
	[Required] public static string coefModule { get; set; } = "";
	[Required] public string firstInputBox { get; set; } = "";
	[Required] public string secondInputBox { get; set; } = "";

	private void SelectedMethod(ChangeEventArgs e)
	{
		result = "";
		errStr = "";
		if (!string.IsNullOrWhiteSpace((string)e.Value))
		{
			selected = (string)e.Value;
		}
	}

	private unsafe void Add()
	{
		try
		{
			int size1, size2;
			var aBytes = PolinomialParser.ParsePolynomial(firstInputBox, out size1);
			var bBytes = PolinomialParser.ParsePolynomial(secondInputBox, out size2);
			byte[] modBytes = Encoding.ASCII.GetBytes(coefModule);
			byte[] errorStrBytes = Encoding.ASCII.GetBytes(errStr);

			int size = 0;

			fixed (byte* modPtr = modBytes)
			fixed (byte* errStrPtr = errorStrBytes)
			{
				byte** resultPtr = PolyRingMethods.polyAddition(ref size, size1, aBytes, size2, bBytes, modPtr, errStrPtr);

				List<string> resultList = new List<string>();
				int offset = 0;
				while (true)
				{
					IntPtr currentPtr = new IntPtr(resultPtr[offset]);
					if (currentPtr == IntPtr.Zero)
						break;

					byte[] currentBytes = Encoding.ASCII.GetBytes(Marshal.PtrToStringAnsi(currentPtr));
					resultList.Add(Encoding.ASCII.GetString(currentBytes));
					offset++;
				}

				string[] resultArray = resultList.ToArray();
				Dictionary<string, int> resultDct = new Dictionary<string, int>();

				foreach (string number in resultArray)
				{
					if (resultDct.ContainsKey(number))
						resultDct[number]++;
					else
						resultDct[number] = 1;
				}

				string res = "";
				foreach (var kvp in resultDct)
				{
					res += "Key: " + kvp.Key + " Value: " + kvp.Value + '\n';
				}
				result = res;
			}
		}
		catch (Exception ex)
		{
			Console.WriteLine(ex.Message);
		}
	}

	private unsafe void Subtract()
	{
		try
		{
			int size1, size2;
			var aBytes = PolinomialParser.ParsePolynomial(firstInputBox, out size1);
			var bBytes = PolinomialParser.ParsePolynomial(secondInputBox, out size2);
			byte[] modBytes = Encoding.ASCII.GetBytes(coefModule);
			byte[] errorStrBytes = Encoding.ASCII.GetBytes(errStr);

			int size = 0;

			fixed (byte* modPtr = modBytes)
			fixed (byte* errStrPtr = errorStrBytes)
			{
				byte** resultPtr = PolyRingMethods.polySubstruction(ref size, size1, aBytes, size2, bBytes, modPtr, errStrPtr);

				List<string> resultList = new List<string>();
				int offset = 0;
				while (true)
				{
					IntPtr currentPtr = new IntPtr(resultPtr[offset]);
					if (currentPtr == IntPtr.Zero)
						break;

					byte[] currentBytes = Encoding.ASCII.GetBytes(Marshal.PtrToStringAnsi(currentPtr));
					resultList.Add(Encoding.ASCII.GetString(currentBytes));
					offset++;
				}

				string[] resultArray = resultList.ToArray();
				Dictionary<string, int> resultDct = new Dictionary<string, int>();

				foreach (string number in resultArray)
				{
					if (resultDct.ContainsKey(number))
						resultDct[number]++;
					else
						resultDct[number] = 1;
				}

				string res = "";
				foreach (var kvp in resultDct)
				{
					res += "Key: " + kvp.Key + " Value: " + kvp.Value + '\n';
				}
				result = res;
			}
		}
		catch (Exception ex)
		{
			Console.WriteLine(ex.Message);
		}
	}

	private unsafe void Multiply()
	{
		try
		{
			int size1, size2;
			var aBytes = PolinomialParser.ParsePolynomial(firstInputBox, out size1);
			var bBytes = PolinomialParser.ParsePolynomial(secondInputBox, out size2);
			byte[] modBytes = Encoding.ASCII.GetBytes(coefModule);
			byte[] errorStrBytes = Encoding.ASCII.GetBytes(errStr);

			int size = 0;

			fixed (byte* modPtr = modBytes)
			fixed (byte* errStrPtr = errorStrBytes)
			{
				byte** resultPtr = PolyRingMethods.polyMultiplication(ref size, size1, aBytes, size2, bBytes, modPtr, errStrPtr);

				List<string> resultList = new List<string>();
				int offset = 0;
				while (true)
				{
					IntPtr currentPtr = new IntPtr(resultPtr[offset]);
					if (currentPtr == IntPtr.Zero)
						break;

					byte[] currentBytes = Encoding.ASCII.GetBytes(Marshal.PtrToStringAnsi(currentPtr));
					resultList.Add(Encoding.ASCII.GetString(currentBytes));
					offset++;
				}

				string[] resultArray = resultList.ToArray();
				Dictionary<string, int> resultDct = new Dictionary<string, int>();

				foreach (string number in resultArray)
				{
					if (resultDct.ContainsKey(number))
						resultDct[number]++;
					else
						resultDct[number] = 1;
				}

				string res = "";
				foreach (var kvp in resultDct)
				{
					res += "Key: " + kvp.Key + " Value: " + kvp.Value + '\n';
				}
				result = res;
			}
		}
		catch (Exception ex)
		{
			Console.WriteLine(ex.Message);
		}
	}

	private void Division()
	{
		//MethodWrapper.addition();
	}

	private void Rest()
	{
		//MethodWrapper.addition();
	}
}